type ERC3000Registry @entity {
  id: ID!
  address: Bytes!
  count: Int!
  games: [OptimisticGame!]
}

type OptimisticGame @entity {
  id: ID!
  name: String!
  queue: GovernQueue!
  roles: [Role]!
  executor: Govern!
}

type Govern @entity {
  id: ID!
  address: Bytes!
  metadata: Bytes
  games: [OptimisticGame!] @derivedFrom(field: "executor")
  executions: [Execution!]
  roles: [Role!]
}

type Execution @entity {
  id: ID!
  sender: Bytes!
  queue: GovernQueue
  actions: [Action!] @derivedFrom(field: "execution")
  results: [Bytes!]
}

type Action @entity {
  id: ID!
  to: Bytes!
  value: BigInt!
  data: Bytes!
  item: Item!
  execution: Execution
  queue: GovernQueue!
  roles: [Role]!
}

type GovernQueue @entity {
  id: ID!
  address: Bytes!
  config: Config
  games: [OptimisticGame!] @derivedFrom(field: "queue")
  queue: [Item!]
  executions: [Execution!] # TODO: @derivedFrom(field: "queue")
  challenges: [Challenge!] @derivedFrom(field: "queue")
  vetos: [Veto!] @derivedFrom(field: "queue")
  roles: [Role!]
}

type Config @entity {
  id: ID!
  queue: GovernQueue!
  executionDelay: BigInt!
  scheduleDeposit: Collateral!
  challengeDeposit: Collateral!
  vetoDeposit: Collateral!
  resolver: Bytes!
  rules: Bytes!
}

type Collateral @entity {
  id: ID!
  token: ERC20!
  amount: BigInt!
}

type ERC20 @entity {
  id: ID!
}

type Item @entity {
  id: ID!
  status: ItemStatus!
  nonce: BigInt!
  executionTime: BigInt!
  submitter: Bytes!
  executor: Govern!
  actions: [Action!] @derivedFrom(field: "item")
  proof: Bytes!
  collateral: Collateral!
  createdAt: BigInt!
}

type Challenge @entity {
  id: ID!
  queue: GovernQueue!
  challenger: Bytes!
  item: Item!
  arbitrator: Bytes!
  disputeId: BigInt!
  evidences: [Evidence!] @derivedFrom(field: "challenge")
  collateral: Collateral!
  ruling: BigInt
  approved: Boolean
  createdAt: BigInt!
}

type Evidence @entity {
  id: ID!
  challenge: Challenge!
  data: Bytes!
  submitter: Bytes!
  createdAt: BigInt!
}

type Veto @entity {
  id: ID!
  queue: GovernQueue!
  item: Item!
  reason: Bytes!
  submitter: Bytes!
  collateral: Collateral!
  createdAt: BigInt!
}

type Role @entity {
  id: ID!
  entity: Bytes!
  selector: Bytes!
  who: Bytes!
  granted: Boolean!
  frozen: Boolean!
}

enum ItemStatus {
  None
  Approved
  Cancelled
  Challenged
  Executed
  Rejected
  Scheduled
  Vetoed
}
