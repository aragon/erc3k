{
  "language": "Solidity",
  "sources": {
    "contracts/Eaglet.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"erc3k/contracts/IERC3000.sol\";\nimport \"erc3k/contracts/ERC3000Executor.sol\";\n\nimport \"./lib/MiniACL.sol\";\n\ncontract Eaglet is ERC3000Executor, MiniACL {\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\n\n    event ETHDeposited(address indexed sender, uint256 value);\n\n    // (Gabi): I found the name _initialExecutor a bit confusing giving the \n    // concept of ERC3000Executor\n    constructor(IERC3000 _initialExecutor) MiniACL(address(this)) public {\n        _grant(EXEC_ROLE, address(_initialExecutor));\n    }\n\n    receive () external payable {\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    function exec(ERC3000Data.Action[] memory actions) override public auth(EXEC_ROLE) returns (bytes[] memory) {\n        bytes[] memory execResults = new bytes[](actions.length);\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            // todo: optimize with assembly\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\n            require(ok, \"eaglet: call\");\n\n            execResults[i] = ret;\n        }\n\n        emit Executed(msg.sender, actions, execResults);\n\n        return execResults;\n    }\n\n    // TODO: ERC-1271\n}\n"
    },
    "erc3k/contracts/IERC3000.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\nimport \"./IERC3000Executor.sol\";\n\nabstract contract IERC3000 {\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 actionHash);\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload, ERC3000Data.Collateral collateral);\n\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes[] memory execResults);\n    event Executed(bytes32 indexed containerHash, address indexed actor, bytes[] execResults);\n\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\n\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes[] memory execResults);\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\n\n    function veto(bytes32 payloadHash, ERC3000Data.Config memory config, bytes memory reason) virtual public;\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason, ERC3000Data.Collateral collateral);\n\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\n    event Configured(bytes32 indexed containerHash, address indexed actor, ERC3000Data.Config config);\n}"
    },
    "erc3k/contracts/ERC3000Data.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC3000Executor.sol\";\n\nlibrary ERC3000Data {\n    // TODO: come up with a non-shitty name\n    struct Container {\n        Payload payload;\n        Config config;\n    }\n\n    struct Payload {\n        uint256 nonce;\n        uint256 executionTime;\n        address submitter;\n        IERC3000Executor executor;\n        Action[] actions;\n        bytes proof;\n    }\n\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    struct Config {\n        uint256 executionDelay;\n        Collateral scheduleDeposit;\n        Collateral challengeDeposit;\n        Collateral vetoDeposit;\n        address resolver;\n        bytes rules;\n    }\n\n    struct Collateral {\n        address token;\n        uint256 amount;\n    }\n\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"erc3k-v1\", this, payloadHash, configHash));\n    }\n\n    function hash(Container memory container) internal view returns (bytes32) {\n        return containerHash(hash(container.payload), hash(container.config));\n    }\n\n    function hash(Payload memory payload) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                payload.nonce,\n                payload.submitter,\n                payload.executor,\n                keccak256(abi.encode(payload.actions)),\n                keccak256(payload.proof)\n            )\n        );\n    }\n\n    function hash(Config memory config) internal pure returns (bytes32) {\n        return keccak256(abi.encode(config));\n    }\n}\n"
    },
    "erc3k/contracts/IERC3000Executor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\n\nabstract contract IERC3000Executor {\n    function exec(ERC3000Data.Action[] memory actions) virtual public returns (bytes[] memory);\n\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes[] execResults);\n}\n"
    },
    "erc3k/contracts/ERC3000Executor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/erc165/ERC165.sol\";\n\nimport \"./IERC3000Executor.sol\";\n\nabstract contract ERC3000Executor is IERC3000Executor, ERC165 {\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\n\n    function supportsInterface(bytes4 _interfaceId) override public pure returns (bool) {\n        return _interfaceId == ERC3000_EXEC_INTERFACE_ID || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "erc3k/contracts/lib/erc165/ERC165.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nabstract contract ERC165 {\n    // Includes supportsInterface method:\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\n\n    /**\n    * @dev Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) virtual public pure returns (bool) {\n        return _interfaceId == ERC165_INTERFACE_ID;\n    }\n}"
    },
    "contracts/lib/MiniACL.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nlibrary MiniACLData {\n    enum BulkOp { Grant, Revoke, Freeze }\n\n    struct BulkItem {\n        BulkOp op;\n        bytes4 role;\n        address who;\n    }\n}\n\ncontract MiniACL {\n    bytes4 public constant ROOT_ROLE =\n        this.grant.selector\n        ^ this.revoke.selector\n        ^ this.freeze.selector\n        ^ this.bulk.selector\n    ;\n\n    address internal constant FREEZE_FLAG = address(1);\n    address internal constant ANY_ADDR = address(-1);\n    \n    mapping (bytes4 => mapping (address => bool)) public roles;\n\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who);\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\n    event Frozen(bytes4 indexed role, address indexed actor);\n\n    modifier auth(bytes4 _role) {\n        require(\n            roles[_role][msg.sender] ||  // sender authorized\n            roles[_role][ANY_ADDR],      // or anyone allowed\n            \"acl: auth\"\n        );\n        _;\n    }\n    \n    constructor(address _initialRoot) public {\n        _grant(ROOT_ROLE, _initialRoot);\n    }\n\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _grant(_role, _who);\n    }\n\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _revoke(_role, _who);\n    }\n\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\n        _freeze(_role);\n    }\n\n    function bulk(MiniACLData.BulkItem[] memory items) public auth(ROOT_ROLE) {\n        for (uint256 i = 0; i < items.length; i++) {\n            MiniACLData.BulkItem memory item = items[i];\n\n            if (item.op == MiniACLData.BulkOp.Grant) _grant(item.role, item.who);\n            else if (item.op == MiniACLData.BulkOp.Revoke) _revoke(item.role, item.who);\n            else if (item.op == MiniACLData.BulkOp.Freeze) _freeze(item.role);\n        }\n    }\n\n    function _grant(bytes4 _role, address _who) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n        require(_who != FREEZE_FLAG, \"acl: bad freeze\");\n        \n        roles[_role][_who] = true;\n        emit Granted(_role, msg.sender, _who);\n    }\n\n    function _revoke(bytes4 _role, address _who) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][_who] = false;\n        emit Revoked(_role, msg.sender, _who);\n    }\n\n    function _freeze(bytes4 _role) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][FREEZE_FLAG] = true;\n\n        emit Frozen(_role, msg.sender);\n    }\n\n    function isFrozen(bytes4 _role) public view returns (bool) {\n        return roles[_role][FREEZE_FLAG];\n    }\n}"
    },
    "contracts/EagletFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./Eaglet.sol\";\nimport \"./ERC3000Registry.sol\";\nimport \"./OptimisticQueue.sol\";\n\ncontract OptimisticQueueFactory {\n    function newQueue(address _aclRoot, ERC3000Data.Config memory _config)\n        public\n        returns (OptimisticQueue queue)\n    {\n        return new OptimisticQueue(_aclRoot, _config);\n    }\n}\n\ncontract EagletFactory {\n    address internal constant ANY_ADDR = address(-1);\n\n    OptimisticQueueFactory public queueFactory;\n    ERC3000Registry public registry;\n\n    constructor(ERC3000Registry _registry, OptimisticQueueFactory _queueFactory) public {\n        queueFactory = _queueFactory;\n        registry = _registry;\n    }\n\n    function newDummyEaglet(string calldata _name) external returns (Eaglet eaglet, OptimisticQueue queue) {\n        ERC3000Data.Collateral memory noCollateral;\n        ERC3000Data.Config memory config = ERC3000Data.Config(\n            0,\n            noCollateral,\n            noCollateral,\n            noCollateral,\n            address(0),\n            \"\"\n        );\n\n        queue = queueFactory.newQueue(address(this), config);\n        eaglet = new Eaglet(queue);\n\n        registry.register(eaglet, queue, _name, \"\");\n\n        MiniACLData.BulkItem[] memory items = new MiniACLData.BulkItem[](6);\n        items[0] = MiniACLData.BulkItem(MiniACLData.BulkOp.Grant, queue.schedule.selector, ANY_ADDR);\n        items[1] = MiniACLData.BulkItem(MiniACLData.BulkOp.Grant, queue.execute.selector, ANY_ADDR);\n        items[2] = MiniACLData.BulkItem(MiniACLData.BulkOp.Grant, queue.challenge.selector, ANY_ADDR);\n        items[3] = MiniACLData.BulkItem(MiniACLData.BulkOp.Grant, queue.configure.selector, address(eaglet));\n        items[4] = MiniACLData.BulkItem(MiniACLData.BulkOp.Revoke, queue.ROOT_ROLE(), address(this));\n        items[5] = MiniACLData.BulkItem(MiniACLData.BulkOp.Freeze, queue.ROOT_ROLE(), address(0));\n\n        queue.bulk(items);\n    }\n}\n"
    },
    "contracts/ERC3000Registry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"erc3k/contracts/ERC3000Executor.sol\";\nimport \"erc3k/contracts/ERC3000.sol\";\n\ncontract ERC3000Registry {\n    bytes4 internal constant ERC3000_INTERFACE_ID = 0x9abf68a8;\n\n    mapping (string => bool) public nameUsed;\n\n    event Registered(ERC3000Executor indexed dao, ERC3000 queue, address indexed registrant, string name);\n    event SetMetadata(ERC3000Executor indexed dao, bytes metadata);\n\n    function register(ERC3000Executor _dao, ERC3000 _queue, string calldata _name, bytes calldata _initialMetadata) external\n    {\n        require(!nameUsed[_name], \"registry: name used\");\n        require(_queue.supportsInterface(ERC3000_INTERFACE_ID), \"registry: bad interface queue\");\n\n        // all will revert if `_dao` is not interface compliant in _setMetadata\n        nameUsed[_name] = true;\n\n        emit Registered(_dao, _queue, msg.sender, _name);\n        _setMetadata(_dao, _initialMetadata);\n    }\n\n    function setMetadata(bytes memory _metadata) public {\n        _setMetadata(ERC3000Executor(msg.sender), _metadata);\n    }\n\n    function _setMetadata(ERC3000Executor _dao, bytes memory _metadata) internal {\n        require(_dao.supportsInterface(_dao.exec.selector), \"registry: bad interface dao\");\n\n        emit SetMetadata(_dao, _metadata);\n    }\n}\n"
    },
    "erc3k/contracts/ERC3000.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/erc165/ERC165.sol\";\n\nimport \"./IERC3000.sol\";\n\nabstract contract ERC3000 is IERC3000, ERC165 {\n    bytes4 internal constant ERC3000_INTERFACE_ID =\n        this.schedule.selector\n        ^ this.execute.selector\n        ^ this.challenge.selector\n        ^ this.resolve.selector\n        ^ this.veto.selector\n        ^ this.configure.selector\n    ;\n\n    function supportsInterface(bytes4 _interfaceId) virtual override public pure returns (bool) {\n        return _interfaceId == ERC3000_INTERFACE_ID || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/OptimisticQueue.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"erc3k/contracts/ERC3000.sol\";\n\nimport \"./lib/IArbitrable.sol\";\nimport \"./lib/DepositLib.sol\";\nimport \"./lib/MiniACL.sol\";\nimport \"./lib/OptimisticQueueStateLib.sol\";\nimport \"./lib/SafeERC20.sol\";\n\ncontract OptimisticQueue is ERC3000, IArbitrable, MiniACL {\n    using ERC3000Data for *;\n    using DepositLib for ERC3000Data.Collateral;\n    using OptimisticQueueStateLib for OptimisticQueueStateLib.Item;\n    using SafeERC20 for ERC20;\n\n    // Permanent state\n    bytes32 public configHash;\n    uint256 public nonce;\n    mapping (bytes32 => OptimisticQueueStateLib.Item) public queue;\n\n    // Temporary state\n    mapping (bytes32 => address) public challengerCache;\n    mapping (IArbitrator => mapping (uint256 => bytes32)) public disputeItemCache;\n\n    constructor(address _aclRoot, ERC3000Data.Config memory _initialConfig)\n        public\n        MiniACL(_aclRoot)\n    {\n        _setConfig(_initialConfig);\n    }\n\n    function schedule(ERC3000Data.Container memory _container)\n        public\n        override\n        auth(this.schedule.selector)\n        returns (bytes32 containerHash)\n    {\n        require(_container.payload.nonce == ++nonce, \"queue: bad nonce\"); // prevent griefing by front-running\n        bytes32 _configHash = _container.config.hash();\n        require(_configHash == configHash, \"queue: bad config\");\n        require(_container.payload.executionTime >= block.timestamp + _container.config.executionDelay, \"queue: bad delay\");\n        require(_container.payload.submitter == msg.sender, \"queue: bad submitter\");\n\n        containerHash = ERC3000Data.containerHash(_container.payload.hash(), _configHash);\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.None,\n            OptimisticQueueStateLib.State.Scheduled\n        );\n\n        ERC3000Data.Collateral memory collateral = _container\n            .config\n            .scheduleDeposit;\n        collateral.collectFrom(msg.sender);\n        // TODO: pay court tx fee\n\n        emit Scheduled(containerHash, _container.payload, collateral);\n    }\n\n    function execute(ERC3000Data.Container memory _container)\n        public\n        override\n        auth(this.execute.selector)\n        returns (bytes[] memory execResults)\n    {\n        require(uint64(block.timestamp) >= _container.payload.executionTime, \"queue: wait more\");\n\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Scheduled,\n            OptimisticQueueStateLib.State.Executed\n        );\n\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter);\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    function challenge(ERC3000Data.Container memory _container, bytes memory _reason) auth(this.challenge.selector) override public returns (uint256 disputeId) {\n        bytes32 containerHash = _container.hash();\n        challengerCache[containerHash] = msg.sender;\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Scheduled,\n            OptimisticQueueStateLib.State.Challenged\n        );\n\n        ERC3000Data.Collateral memory collateral = _container.config.challengeDeposit;\n        collateral.collectFrom(msg.sender);\n\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\n        (address recipient, ERC20 feeToken, uint256 feeAmount) = arbitrator.getDisputeFees();\n        require(feeToken.safeTransferFrom(msg.sender, address(this), feeAmount), \"queue: bad fee pull\");\n        require(feeToken.safeApprove(recipient, feeAmount), \"queue: bad approve\");\n        disputeId = arbitrator.createDispute(2, abi.encode(_container));\n        require(feeToken.safeApprove(recipient, 0), \"queue: bad reset\"); // for security with non-compliant tokens (that fail on non-zero to non-zero approvals)\n\n        emit EvidenceSubmitted(arbitrator, disputeId, _container.payload.submitter, _container.payload.proof, true);\n        emit EvidenceSubmitted(arbitrator, disputeId, msg.sender, _reason, true);\n        arbitrator.closeEvidencePeriod(disputeId);\n\n        disputeItemCache[arbitrator][disputeId] = containerHash;\n\n        emit Challenged(containerHash, msg.sender, _reason, disputeId, collateral);\n    }\n\n    function resolve(ERC3000Data.Container memory _container, uint256 _resolverId) override public returns (bytes[] memory execResults) {\n        bytes32 containerHash = _container.hash();\n        if (queue[containerHash].state == OptimisticQueueStateLib.State.Challenged) {\n            // will re-enter in `rule`, `rule` will perform state transition depending on ruling\n            IArbitrator(_container.config.resolver).executeRuling(_resolverId);\n        }\n\n        bool approved = queue[containerHash].state == OptimisticQueueStateLib.State.Approved;\n        if (approved) {\n            execResults = executeApproved(_container);\n        } else {\n            settleRejection(_container);\n        }\n\n        emit Resolved(containerHash, msg.sender, approved);\n    }\n\n    function veto(bytes32 _payloadHash, ERC3000Data.Config memory _config, bytes memory _reason) auth(this.veto.selector) override public {\n        bytes32 containerHash = ERC3000Data.containerHash(_payloadHash, _config.hash());\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Scheduled,\n            OptimisticQueueStateLib.State.Cancelled\n        );\n\n        emit Vetoed(containerHash, msg.sender, _reason, _config.vetoDeposit);\n    }\n\n    function configure(ERC3000Data.Config memory _config)\n        public\n        override\n        auth(this.configure.selector)\n        returns (bytes32)\n    {\n        return _setConfig(_config);\n    }\n\n    // Finalization functions\n    // In the happy path, they are never externally called, but left public for security\n\n    function executeApproved(ERC3000Data.Container memory _container) public returns (bytes[] memory execResults) {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Approved,\n            OptimisticQueueStateLib.State.Executed\n        );\n\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter);\n        _container.config.challengeDeposit.releaseTo(_container.payload.submitter);\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    function settleRejection(ERC3000Data.Container memory _container) public {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Rejected,\n            OptimisticQueueStateLib.State.Cancelled\n        );\n\n        address challenger = challengerCache[containerHash];\n        _container.config.scheduleDeposit.releaseTo(challenger);\n        _container.config.challengeDeposit.releaseTo(challenger);\n        challengerCache[containerHash] = address(0); // refund gas, no longer needed in state\n    }\n\n    // Arbitrable\n    function rule(uint256 _disputeId, uint256 _ruling) override external {\n        IArbitrator arbitrator = IArbitrator(msg.sender);\n        bytes32 containerHash = disputeItemCache[arbitrator][_disputeId];\n        queue[containerHash].checkAndSetState(\n            OptimisticQueueStateLib.State.Challenged,\n            _ruling == ALLOW_RULING ? OptimisticQueueStateLib.State.Approved : OptimisticQueueStateLib.State.Rejected\n        );\n        disputeItemCache[arbitrator][_disputeId] = bytes32(0); // refund gas, no longer needed in state\n\n        emit Ruled(arbitrator, _disputeId, _ruling);\n    }\n\n    function submitEvidence(\n        uint256,\n        bytes calldata,\n        bool\n    ) external override {\n        revert(\"queue: evidence\");\n    }\n\n    // ERC-165\n\n    function supportsInterface(bytes4 _interfaceId) override public pure returns (bool) {\n        return _interfaceId == ARBITRABLE_INTERFACE_ID || super.supportsInterface(_interfaceId);\n    }\n\n    // Internal\n\n    function _execute(ERC3000Data.Payload memory _payload, bytes32 _containerHash) internal returns (bytes[] memory execResults) {\n        execResults = _payload.executor.exec(_payload.actions);\n        emit Executed(_containerHash, msg.sender, execResults);\n    }\n\n    function _setConfig(ERC3000Data.Config memory _config)\n        internal\n        returns (bytes32)\n    {\n        configHash = _config.hash();\n\n        emit Configured(configHash, msg.sender, _config);\n\n        return configHash;\n    }\n}\n"
    },
    "contracts/lib/IArbitrable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrable.sol\n\npragma solidity ^0.6.8;\n\nimport \"./IArbitrator.sol\";\n\nabstract contract IArbitrable {\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\n    uint256 internal constant ALLOW_RULING = 4;\n\n    /**\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n    * @param arbitrator IArbitrator instance ruling the dispute\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n    * @param ruling Ruling given by the arbitrator\n    */\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n\n    /**\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\n    * @param arbitrator IArbitrator submitting the evidence for\n    * @param disputeId Identification number of the dispute receiving new evidence\n    * @param submitter Address of the account submitting the evidence\n    * @param evidence Data submitted for the evidence of the dispute\n    * @param finished Whether or not the submitter has finished submitting evidence\n    */\n    event EvidenceSubmitted(IArbitrator indexed arbitrator, uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\n\n    /**\n    * @dev Submit evidence for a dispute\n    * @param _disputeId Id of the dispute in the Court\n    * @param _evidence Data submitted for the evidence related to the dispute\n    * @param _finished Whether or not the submitter has finished submitting evidence\n    */\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) virtual external;\n\n    /**\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\n    * @param _disputeId Identification number of the dispute to be ruled\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\n    */\n    function rule(uint256 _disputeId, uint256 _ruling) virtual external;\n}"
    },
    "contracts/lib/IArbitrator.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrator.sol\n\npragma solidity ^0.6.8;\n\nimport \"./SafeERC20.sol\";\n\ninterface IArbitrator {\n    /**\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\n    * @param _disputeId Identification number of the dispute to be executed\n    */\n    function executeRuling(uint256 _disputeId) external;\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\n    * @param _subscriber Address of the account paying the subscription fees for\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n}"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\n\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n\npragma solidity ^0.6.8;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\nabstract contract ERC20 {\n    function totalSupply() virtual public view returns (uint256);\n\n    function balanceOf(address _who) virtual public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        virtual public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        virtual public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        virtual public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeERC20 {\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas(),                // forward all \n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize()\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas(),                // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            _token.transfer.selector,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(address(_token), balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(address(_token), allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(address(_token), totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}"
    },
    "contracts/lib/DepositLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"erc3k/contracts/ERC3000Data.sol\";\n\nimport \"./SafeERC20.sol\";\n\nlibrary DepositLib {\n    using SafeERC20 for ERC20;\n\n    event Collected(address indexed token, address indexed from, uint256 amount);\n    event Released(address indexed token, address indexed to, uint256 amount);\n\n    function collectFrom(ERC3000Data.Collateral memory _collateral, address _from) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            require(token.safeTransferFrom(_from, msg.sender, _collateral.amount), \"queue: bad get token\");\n\n            emit Collected(_collateral.token, _from, _collateral.amount);\n        }\n    }\n\n    function releaseTo(ERC3000Data.Collateral memory _collateral, address _to) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            require(token.safeTransfer(_to, _collateral.amount), \"queue: bad send token\");\n\n            emit Released(_collateral.token, _to, _collateral.amount);\n        }\n    }\n}"
    },
    "contracts/lib/OptimisticQueueStateLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nlibrary OptimisticQueueStateLib {\n    enum State {\n        None,\n        Scheduled,\n        Challenged,\n        Approved,\n        Rejected,\n        Cancelled,\n        Executed\n    }\n\n    struct Item {\n        State state;\n    }\n\n    function checkState(Item storage _item, State _requiredState) internal view {\n        require(_item.state == _requiredState, \"queue: bad state\");\n    }\n\n    function setState(Item storage _item, State _state) internal {\n        _item.state = _state;\n    }\n\n    function checkAndSetState(Item storage _item, State _fromState, State _toState) internal {\n        checkState(_item, _fromState);\n        setState(_item, _toState);\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}