{
  "address": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract GovernRegistry",
          "name": "_registry",
          "type": "address"
        },
        {
          "internalType": "contract GovernFactory",
          "name": "_governFactory",
          "type": "address"
        },
        {
          "internalType": "contract GovernQueueFactory",
          "name": "_queueFactory",
          "type": "address"
        },
        {
          "internalType": "contract GovernTokenFactory",
          "name": "_tokenFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "governFactory",
      "outputs": [
        {
          "internalType": "contract GovernFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "internalType": "contract IERC20",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "_tokenName",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_tokenSymbol",
          "type": "string"
        },
        {
          "internalType": "bool",
          "name": "_useProxies",
          "type": "bool"
        }
      ],
      "name": "newGovernWithoutConfig",
      "outputs": [
        {
          "internalType": "contract Govern",
          "name": "govern",
          "type": "address"
        },
        {
          "internalType": "contract GovernQueue",
          "name": "queue",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "queueFactory",
      "outputs": [
        {
          "internalType": "contract GovernQueueFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registry",
      "outputs": [
        {
          "internalType": "contract GovernRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tokenFactory",
      "outputs": [
        {
          "internalType": "contract GovernTokenFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc5a7df49d1335f128409a291815b75a2caa5d1a1fa9e4aac36c3bd4697a0602d",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
    "transactionIndex": 0,
    "gasUsed": "932942",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x93cc1cb6beab1e650b78bb02c3e7eeb52653e2b1a7a3c67542ef97c39142d1f7",
    "transactionHash": "0xc5a7df49d1335f128409a291815b75a2caa5d1a1fa9e4aac36c3bd4697a0602d",
    "logs": [],
    "blockNumber": 7,
    "cumulativeGasUsed": "932942",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x51C523E0eEDD112C5a08803951466Cd10271b0fF",
    "0x091bB90D7D53dE1B8C3C1737f7F242b78E5f28F0",
    "0x544ADee3ee41aEa40bED5c6E0a5575A20169362e",
    "0xC52666F505B8231d6C4C793E46B9aF4f00405653"
  ],
  "solcInputHash": "ab40b143b50742d171e87e19303a80b3",
  "metadata": "{\"compiler\":{\"version\":\"0.6.8+commit.0bbfe453\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract GovernRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract GovernFactory\",\"name\":\"_governFactory\",\"type\":\"address\"},{\"internalType\":\"contract GovernQueueFactory\",\"name\":\"_queueFactory\",\"type\":\"address\"},{\"internalType\":\"contract GovernTokenFactory\",\"name\":\"_tokenFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"governFactory\",\"outputs\":[{\"internalType\":\"contract GovernFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_useProxies\",\"type\":\"bool\"}],\"name\":\"newGovernWithoutConfig\",\"outputs\":[{\"internalType\":\"contract Govern\",\"name\":\"govern\",\"type\":\"address\"},{\"internalType\":\"contract GovernQueue\",\"name\":\"queue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queueFactory\",\"outputs\":[{\"internalType\":\"contract GovernQueueFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract GovernRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"internalType\":\"contract GovernTokenFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/GovernBaseFactory.sol\":\"GovernBaseFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../initializable/Initializable.sol\\\";\\n\\nimport \\\"./IACLOracle.sol\\\";\\n\\nlibrary ACLData {\\n    enum BulkOp { Grant, Revoke, Freeze }\\n\\n    struct BulkItem {\\n        BulkOp op;\\n        bytes4 role;\\n        address who;\\n    }\\n}\\n\\ncontract ACL is Initializable {\\n    bytes4 public constant ROOT_ROLE =\\n        this.grant.selector\\n        ^ this.revoke.selector\\n        ^ this.freeze.selector\\n        ^ this.bulk.selector\\n    ;\\n\\n    address internal constant FREEZE_FLAG = address(1);\\n    address internal constant ANY_ADDR = address(-1);\\n\\n    address internal constant UNSET_ROLE = address(0);\\n    address internal constant ALLOW_FLAG = address(2);\\n    \\n    mapping (bytes4 => mapping (address => address)) public roles;\\n\\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\\n    event Frozen(bytes4 indexed role, address indexed actor);\\n\\n    modifier auth(bytes4 _role) {\\n        require(willPerform(_role, msg.sender, msg.data), \\\"acl: auth\\\");\\n        _;\\n    }\\n\\n    modifier initACL(address _initialRoot) {\\n        // ACL might have been already initialized by constructors\\n        if (initBlocks[\\\"acl\\\"] == 0) {\\n            _initializeACL(_initialRoot);\\n        }\\n        _;\\n    }\\n\\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\\n\\n    function _initializeACL(address _initialRoot) internal onlyInit(\\\"acl\\\") {\\n        _grant(ROOT_ROLE, _initialRoot);\\n    }\\n\\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _grant(_role, _who);\\n    }\\n\\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\\n        _grantWithOracle(_role, _who, _oracle);\\n    }\\n\\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _revoke(_role, _who);\\n    }\\n\\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\\n        _freeze(_role);\\n    }\\n\\n    function bulk(ACLData.BulkItem[] memory items) public auth(ROOT_ROLE) {\\n        for (uint256 i = 0; i < items.length; i++) {\\n            ACLData.BulkItem memory item = items[i];\\n\\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\\n        }\\n    }\\n\\n    function willPerform(bytes4 _role, address _sender, bytes memory _data) public returns (bool) {\\n        address senderRole = roles[_role][msg.sender];\\n        if (senderRole != UNSET_ROLE) {\\n            if (senderRole == ALLOW_FLAG) return true;\\n            if (IACLOracle(senderRole).willPerform(_role, _sender, _data)) return true;\\n        }\\n\\n        address anyRole = roles[_role][ANY_ADDR];\\n        if (anyRole != UNSET_ROLE) {\\n            if (anyRole == ALLOW_FLAG) return true;\\n            if (IACLOracle(anyRole).willPerform(_role, _sender, _data)) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _grant(bytes4 _role, address _who) internal {\\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\\n    }\\n\\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n        require(_who != FREEZE_FLAG, \\\"acl: bad freeze\\\");\\n        \\n        roles[_role][_who] = address(_oracle);\\n        emit Granted(_role, msg.sender, _who, _oracle);\\n    }\\n\\n    function _revoke(bytes4 _role, address _who) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][_who] = UNSET_ROLE;\\n        emit Revoked(_role, msg.sender, _who);\\n    }\\n\\n    function _freeze(bytes4 _role) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\\n\\n        emit Frozen(_role, msg.sender);\\n    }\\n\\n    function isFrozen(bytes4 _role) public view returns (bool) {\\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\\n    }\\n}\",\"keccak256\":\"0xfc3130638c04860e1006ccc2a765c36f22a3eadb2f095098f49d37ed26c073cc\",\"license\":\"GPL-3.0\"},\"@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity 0.6.8;\\n\\ninterface IACLOracle {\\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\\n}\",\"keccak256\":\"0x978bedb926117b472212ea90debf71b4274bf1e1e673f541247cc01c93b55062\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../erc165/ERC165.sol\\\";\\n\\ncontract AdaptativeERC165 is ERC165 {\\n    // erc165 interface ID -> whether it is supported\\n    mapping (bytes4 => bool) internal standardSupported;\\n    // callback function signature -> magic number to return\\n    mapping (bytes4 => bytes32) internal callbackMagicNumbers;\\n\\n    bytes32 internal constant UNREGISTERED_CALLBACK = bytes32(0);\\n\\n    event RegisteredStandard(bytes4 interfaceId);\\n    event RegisteredCallback(bytes4 sig, bytes4 magicNumber);\\n    event ReceivedCallback(bytes4 indexed sig, bytes data);\\n\\n    function supportsInterface(bytes4 _interfaceId) override virtual public view returns (bool) {\\n        return standardSupported[_interfaceId] || super.supportsInterface(_interfaceId);\\n    }\\n\\n    function _handleCallback(bytes4 _sig, bytes memory _data) internal {\\n        bytes32 magicNumber = callbackMagicNumbers[_sig];\\n        require(magicNumber != UNREGISTERED_CALLBACK, \\\"adap-erc165: unknown callback\\\");\\n\\n        emit ReceivedCallback(_sig, _data);\\n\\n        // low-level return magic number\\n        assembly {\\n            mstore(0x00, magicNumber)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    function _registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) internal {\\n        _registerStandard(_interfaceId);\\n        _registerCallback(_callbackSig, _magicNumber);\\n    }\\n\\n    function _registerStandard(bytes4 _interfaceId) internal {\\n        // use a random magic number for standards without number\\n        standardSupported[_interfaceId] = true;\\n\\n        emit RegisteredStandard(_interfaceId);\\n    }\\n\\n    function _registerCallback(bytes4 _callbackSig, bytes4 _magicNumber) internal {\\n        callbackMagicNumbers[_callbackSig] = _magicNumber;\\n\\n        emit RegisteredCallback(_callbackSig, _magicNumber);\\n    }\\n}\",\"keccak256\":\"0x38499e059897298638ffbcdd3d191c4f345e0a2537fd70d3cd17d47758b4cca2\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nlibrary AddressUtils {\\n    function toPayable(address addr) internal pure returns (address payable) {\\n        return address(bytes20(addr));\\n    }\\n\\n    function toAddress(address addr) internal pure returns (address payable) {\\n        return address(bytes20(addr));\\n    }\\n\\n    function isContract(address addr) internal view returns (bool result) {\\n        assembly {\\n            result := not(iszero(extcodesize(addr)))\\n        }\\n    }\\n}\",\"keccak256\":\"0x64afde65cee1947a6b5a53730e0c42c71d6042e461b0f39d5713c7f6771757f2\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nlibrary BitmapLib {\\n    bytes32 constant internal empty = bytes32(0);\\n    bytes32 constant internal allowAll = empty;\\n    bytes32 constant internal denyAll = bytes32(uint256(-1));\\n\\n    function flip(bytes32 map, uint8 index) internal pure returns (bytes32) {\\n        return bytes32(uint256(map) ^ uint256(1) << index);\\n    }\\n\\n    function get(bytes32 map, uint8 index) internal pure returns (bool) {\\n        return bool(uint256(map) >> index & 1 == 1);\\n    }\\n}\\n\",\"keccak256\":\"0xb4d5bb80d9fdbbc3010d261d6431d99c8532423098bc15b582670f87efc80734\",\"license\":\"GPL-3.0\"},\"@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"erc3k/contracts/ERC3000Data.sol\\\";\\n\\nimport \\\"../erc20/SafeERC20.sol\\\";\\n\\nlibrary DepositLib {\\n    using SafeERC20 for ERC20;\\n\\n    event Lock(address indexed token, address indexed from, uint256 amount);\\n    event Unlock(address indexed token, address indexed to, uint256 amount);\\n\\n    function collectFrom(ERC3000Data.Collateral memory _collateral, address _from) internal {\\n        if (_collateral.amount > 0) {\\n            ERC20 token = ERC20(_collateral.token);\\n            require(token.safeTransferFrom(_from, address(this), _collateral.amount), \\\"queue: bad get token\\\");\\n\\n            emit Lock(_collateral.token, _from, _collateral.amount);\\n        }\\n    }\\n\\n    function releaseTo(ERC3000Data.Collateral memory _collateral, address _to) internal {\\n        if (_collateral.amount > 0) {\\n            ERC20 token = ERC20(_collateral.token);\\n            require(token.safeTransfer(_to, _collateral.amount), \\\"queue: bad send token\\\");\\n\\n            emit Unlock(_collateral.token, _to, _collateral.amount);\\n        }\\n    }\\n}\",\"keccak256\":\"0x882fc25e75b2be510e30442e1448559437dd21e250cf7c2ff72161d64f0b0889\",\"license\":\"GPL-3.0\"},\"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nabstract contract ERC165 {\\n    // Includes supportsInterface method:\\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\\n        return _interfaceId == ERC165_INTERFACE_ID\\n          || block.timestamp == 1; // silence visibility warning needed for overrides\\n    }\\n}\",\"keccak256\":\"0x48bc84112e6ba3faee6e57081d97284338bda87af97e1353a957701b8059c80d\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\\n\\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../address-utils/AddressUtils.sol\\\";\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 {\\n    function totalSupply() virtual public view returns (uint256);\\n\\n    function balanceOf(address _who) virtual public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n        virtual public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n        virtual public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        virtual public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \\\"SAFE_ERC_20_BALANCE_REVERTED\\\";\\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \\\"SAFE_ERC_20_ALLOWANCE_REVERTED\\\";\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool ret)\\n    {\\n        if (!_addr.isContract()) {\\n            return false;\\n        }\\n\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas(),                // forward all \\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize()\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := eq(mload(ptr), 1)\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            _token.transfer.selector,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), approveCallData);\\n    }\\n}\",\"keccak256\":\"0xf5c2b2fceb1f639cb56c6e6e098955a5583d4e240b7a021c0e3afa9de60374f4\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity 0.6.8;\\n\\ncontract Initializable {\\n    mapping (string => uint256) public initBlocks;\\n\\n    event Initialized(string indexed key);\\n\\n    modifier onlyInit(string memory key) {\\n        require(initBlocks[key] == 0, \\\"initializable: already initialized\\\");\\n        initBlocks[key] = block.number;\\n        _;\\n        emit Initialized(key);\\n    }\\n}\",\"keccak256\":\"0xebf2390cfe1c1d57fa3d2dae190a56db50d03fdd6732f8aef233a34581f5760b\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// Inspired by: https://github.com/optionality/clone-factory\\n\\npragma solidity ^0.6.8;\\n\\nlibrary ERC1167ProxyFactory {\\n    function clone(address _implementation) internal returns (address cloneAddr) {\\n        bytes memory code = generateCode(_implementation);\\n\\n        assembly {\\n            cloneAddr := create(0, add(code, 0x20), 55)\\n        }\\n        \\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create\\\");\\n    }\\n\\n    function clone(address _implementation, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone(_implementation);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt) internal returns (address cloneAddr) {\\n        bytes memory code = generateCode(_implementation);\\n        \\n        assembly {\\n            cloneAddr := create2(0, add(code, 0x20), 55, _salt)\\n        }\\n        \\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create2\\\");\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone2(_implementation, _salt);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function generateCode(address _implementation) internal pure returns (bytes memory code) {\\n        code = new bytes(55);\\n        \\n        assembly {\\n            mstore(add(code, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(code, 0x34), shl(0x60, _implementation))\\n            mstore(add(code, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n        }\\n    }\\n\\n    // From: https://ethereum.stackexchange.com/a/83577\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return '';\\n\\n        assembly {\\n            _returnData := add(_returnData, 0x04) // Slice the sighash.\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n}\\n\",\"keccak256\":\"0x2c92620c6ebd44fe19cad226d25f53c4c05be0c680249ec1b01832f7715e7dd9\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/protocol/IArbitrable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrable.sol\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"./IArbitrator.sol\\\";\\n\\nabstract contract IArbitrable {\\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\\n    uint256 internal constant ALLOW_RULING = 4;\\n\\n    /**\\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\\n    * @param arbitrator IArbitrator instance ruling the dispute\\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\\n    * @param ruling Ruling given by the arbitrator\\n    */\\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\\n\\n    /**\\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\\n    * @param arbitrator IArbitrator submitting the evidence for\\n    * @param disputeId Identification number of the dispute receiving new evidence\\n    * @param submitter Address of the account submitting the evidence\\n    * @param evidence Data submitted for the evidence of the dispute\\n    * @param finished Whether or not the submitter has finished submitting evidence\\n    */\\n    event EvidenceSubmitted(IArbitrator indexed arbitrator, uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\\n\\n    /**\\n    * @dev Submit evidence for a dispute\\n    * @param _disputeId Id of the dispute in the Court\\n    * @param _evidence Data submitted for the evidence related to the dispute\\n    * @param _finished Whether or not the submitter has finished submitting evidence\\n    */\\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) virtual external;\\n\\n    /**\\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\\n    * @param _disputeId Identification number of the dispute to be ruled\\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \\\"refused to make a decision\\\"\\n    */\\n    function rule(uint256 _disputeId, uint256 _ruling) virtual external;\\n}\",\"keccak256\":\"0x90eb43471eae9e12139e544fd5bf35e0a285cb5f2b2920b06f567392d417c96b\",\"license\":\"MIT\"},\"@aragon/govern-contract-utils/contracts/protocol/IArbitrator.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrator.sol\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../erc20/SafeERC20.sol\\\";\\n\\ninterface IArbitrator {\\n    /**\\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\\n    * @return Dispute identification number\\n    */\\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\\n\\n    /**\\n    * @dev Close the evidence period of a dispute\\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\\n    */\\n    function closeEvidencePeriod(uint256 _disputeId) external;\\n\\n    /**\\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\\n    * @param _disputeId Identification number of the dispute to be executed\\n    */\\n    function executeRuling(uint256 _disputeId) external;\\n\\n    /**\\n    * @dev Tell the dispute fees information to create a dispute\\n    * @return recipient Address where the corresponding dispute fees must be transferred to\\n    * @return feeToken ERC20 token used for the fees\\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\\n    */\\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\\n\\n    /**\\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\\n    * @param _subscriber Address of the account paying the subscription fees for\\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\\n    * @return feeToken ERC20 token used for the subscription fees\\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\\n    */\\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\\n}\",\"keccak256\":\"0xee70f23c164a044943b02709dd7af3a23187b97a4319a1a08dd2aa531c6573f1\",\"license\":\"MIT\"},\"@aragon/govern-core/contracts/Govern.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"erc3k/contracts/IERC3000Executor.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\\\";\\n\\ncontract Govern is AdaptativeERC165, IERC3000Executor, ACL {\\n    using BitmapLib for bytes32;\\n\\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\\n    bytes4 internal constant REGISTER_ROLE = this.registerStandardAndCallback.selector;\\n    uint256 internal constant MAX_ACTIONS = 256;\\n\\n    event ETHDeposited(address indexed sender, uint256 value);\\n\\n    constructor(address _initialExecutor) ACL(address(this)) public {\\n        initialize(_initialExecutor);\\n    }\\n\\n    function initialize(address _initialExecutor) public initACL(_initialExecutor) onlyInit(\\\"govern\\\") {\\n        _grant(EXEC_ROLE, address(_initialExecutor));\\n        _grant(REGISTER_ROLE, address(_initialExecutor));\\n        _registerStandard(ERC3000_EXEC_INTERFACE_ID);\\n    }\\n\\n    receive () external payable {\\n        emit ETHDeposited(msg.sender, msg.value);\\n    }\\n\\n    fallback () external {\\n        _handleCallback(msg.sig, msg.data); // WARN: does a low-level return, any code below would be unreacheable\\n    }\\n\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) override public auth(EXEC_ROLE) returns (bytes32, bytes[] memory) {\\n        require(actions.length <= MAX_ACTIONS, \\\"govern: too many\\\"); // need to limit since we use 256-bit bitmaps\\n        \\n        bytes[] memory execResults = new bytes[](actions.length);\\n        bytes32 failureMap = BitmapLib.empty; // start with an empty bitmap\\n\\n        for (uint256 i = 0; i < actions.length; i++) { // can use uint8 given the action limit\\n            // TODO: optimize with assembly\\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\\n            require(ok || allowFailuresMap.get(uint8(i)), \\\"govern: call\\\");\\n            // if a call fails, flip that bit to signal failure\\n            failureMap = ok ? failureMap : failureMap.flip(uint8(i));\\n            execResults[i] = ret;\\n        }\\n\\n        emit Executed(msg.sender, actions, memo, failureMap, execResults);\\n\\n        return (failureMap, execResults);\\n    }\\n\\n    function registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) external auth(REGISTER_ROLE) {\\n        _registerStandardAndCallback(_interfaceId, _callbackSig, _magicNumber);\\n    }\\n\\n    // TODO: ERC-1271\\n}\\n\",\"keccak256\":\"0x9d015f4a86ca595d17accfd2bc503b6f6151344f260062226ae596d696f470ef\",\"license\":\"GPL-3.0\"},\"@aragon/govern-core/contracts/GovernRegistry.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000Executor.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000Registry.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\\\";\\n\\ncontract GovernRegistry is IERC3000Registry {\\n    mapping(string => bool) public nameUsed;\\n\\n    function register(\\n        IERC3000Executor _executor,\\n        IERC3000 _queue,\\n        IERC20 _token,\\n        string calldata _name,\\n        bytes calldata _initialMetadata\\n    ) override external\\n    {\\n        require(!nameUsed[_name], \\\"registry: name used\\\");\\n\\n        nameUsed[_name] = true;\\n\\n        emit Registered(_executor, _queue, _token, msg.sender, _name);\\n        _setMetadata(_executor, _initialMetadata);\\n    }\\n\\n    function setMetadata(bytes memory _metadata) override public {\\n        _setMetadata(IERC3000Executor(msg.sender), _metadata);\\n    }\\n\\n    function _setMetadata(IERC3000Executor _executor, bytes memory _metadata) internal {\\n        emit SetMetadata(_executor, _metadata);\\n    }\\n}\\n\",\"keccak256\":\"0xf74e1f0675b81489a914b337b16f9010cda1152da59095af238114a2fdce633e\",\"license\":\"GPL-3.0\"},\"@aragon/govern-core/contracts/pipelines/GovernQueue.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8; // TODO: reconsider compiler version before production release\\npragma experimental ABIEncoderV2; // required for passing structs in calldata (fairly secure at this point)\\n\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/protocol/IArbitrable.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\\\";\\n\\nlibrary GovernQueueStateLib {\\n    enum State {\\n        None,\\n        Scheduled,\\n        Challenged,\\n        Approved,\\n        Rejected,\\n        Cancelled,\\n        Executed\\n    }\\n\\n    struct Item {\\n        State state;\\n    }\\n\\n    function checkState(Item storage _item, State _requiredState) internal view {\\n        require(_item.state == _requiredState, \\\"queue: bad state\\\");\\n    }\\n\\n    function setState(Item storage _item, State _state) internal {\\n        _item.state = _state;\\n    }\\n\\n    function checkAndSetState(Item storage _item, State _fromState, State _toState) internal {\\n        checkState(_item, _fromState);\\n        setState(_item, _toState);\\n    }\\n}\\n\\ncontract GovernQueue is IERC3000, AdaptativeERC165, IArbitrable, ACL {\\n    // Syntax sugar to enable method-calling syntax on types\\n    using ERC3000Data for *;\\n    using DepositLib for ERC3000Data.Collateral;\\n    using GovernQueueStateLib for GovernQueueStateLib.Item;\\n    using SafeERC20 for ERC20;\\n\\n    // Permanent state\\n    bytes32 public configHash; // keccak256 hash of the current ERC3000Data.Config\\n    uint256 public nonce; // number of scheduled payloads so far\\n    mapping (bytes32 => GovernQueueStateLib.Item) public queue; // container hash -> execution state\\n\\n    // Temporary state\\n    mapping (bytes32 => address) public challengerCache; // container hash -> challenger addr (used after challenging and before resolution implementation)\\n    mapping (IArbitrator => mapping (uint256 => bytes32)) public disputeItemCache; // arbitrator addr -> dispute id -> container hash (used between dispute creation and ruling)\\n\\n    /**\\n     * @param _aclRoot account that will be given root permissions on ACL (commonly given to factory)\\n     * @param _initialConfig initial configuration parameters\\n     */\\n    constructor(address _aclRoot, ERC3000Data.Config memory _initialConfig)\\n        public\\n        ACL(_aclRoot) // note that this contract directly derives from ACL (ACL is local to contract and not global to system in Govern)\\n    {\\n        initialize(_aclRoot, _initialConfig);\\n    }\\n\\n    function initialize(address _aclRoot, ERC3000Data.Config memory _initialConfig) public initACL(_aclRoot) onlyInit(\\\"queue\\\") {\\n        _setConfig(_initialConfig);\\n        _registerStandard(ARBITRABLE_INTERFACE_ID);\\n        _registerStandard(ERC3000_INTERFACE_ID);\\n    }\\n\\n     /**\\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window. Pulls collateral from submitter into contract.\\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\\n       the current configuration of the system\\n     */\\n    function schedule(ERC3000Data.Container memory _container) // TO FIX: Container is in memory and function has to be public to avoid an unestrutable solidity crash\\n        public\\n        override\\n        auth(this.schedule.selector) // note that all functions in this contract are ACL protected (commonly some of them will be open for any addr to perform)\\n        returns (bytes32 containerHash)\\n    {   \\n        // prevent griefing by front-running (the same container is sent by two different people and one must be challenged)\\n        require(_container.payload.nonce == ++nonce, \\\"queue: bad nonce\\\");\\n        // hash using ERC3000Data.hash(ERC3000Data.Config)\\n        bytes32 _configHash = _container.config.hash();\\n        // ensure that the hash of the config passed in the container matches the current config (implicit agreement approval by scheduler)\\n        require(_configHash == configHash, \\\"queue: bad config\\\");\\n        // ensure that the time delta to the execution timestamp provided in the payload is at least after the config's execution delay\\n        require(_container.payload.executionTime >= block.timestamp + _container.config.executionDelay, \\\"queue: bad delay\\\");\\n        // ensure that the submitter of the payload is also the sender of this call\\n        require(_container.payload.submitter == msg.sender, \\\"queue: bad submitter\\\");\\n\\n        containerHash = ERC3000Data.containerHash(_container.payload.hash(), _configHash);\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.None, // ensure that the state for this container is None\\n            GovernQueueStateLib.State.Scheduled // and if so perform a state transition to Scheduled\\n        );\\n        // we don't need to save any more state about the container in storage\\n        // we just authenticate the hash and assign it a state, since all future\\n        // actions regarding the container will need to provide it as a witness\\n        // all witnesses are logged from this contract at least once, so the \\n        // trust assumption should be the same as storing all on-chain (move complexity to clients)\\n\\n        ERC3000Data.Collateral memory collateral = _container.config.scheduleDeposit;\\n        collateral.collectFrom(_container.payload.submitter); // pull collateral from submitter (requires previous approval)\\n\\n        // TODO: pay court tx fee\\n\\n        // emit an event to ensure data availability of all state that cannot be otherwise fetched (see how config isn't emitted since an observer should already have it)\\n        emit Scheduled(containerHash, _container.payload);\\n    }\\n\\n    /**\\n     * @notice Executes an action after its execution delayed has passed and its state hasn't been altered by a challenge or veto\\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\\n       the current configuration of the system\\n     */\\n    function execute(ERC3000Data.Container memory _container)\\n        public\\n        override\\n        auth(this.execute.selector) // in most instances this will be open for any addr, but leaving configurable for flexibility\\n        returns (bytes32 failureMap, bytes[] memory execResults)\\n    {\\n        // ensure enough time has passed\\n        require(uint64(block.timestamp) >= _container.payload.executionTime, \\\"queue: wait more\\\");\\n\\n        bytes32 containerHash = _container.hash();\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Scheduled, // note that we will revert here if the container wasn't previously scheduled\\n            GovernQueueStateLib.State.Executed\\n        );\\n\\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter); // release collateral to executor\\n\\n        return _execute(_container.payload, containerHash);\\n    }\\n\\n    /**\\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\\n       the current configuration of the system\\n     * @param _reason Hint for case reviewers as to why the scheduled container is illegal\\n     */\\n    function challenge(ERC3000Data.Container memory _container, bytes memory _reason) auth(this.challenge.selector) override public returns (uint256 disputeId) {\\n        bytes32 containerHash = _container.hash();\\n        challengerCache[containerHash] = msg.sender; // cache challenger address while it is needed\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Scheduled,\\n            GovernQueueStateLib.State.Challenged\\n        );\\n\\n        ERC3000Data.Collateral memory collateral = _container.config.challengeDeposit;\\n        collateral.collectFrom(msg.sender); // pull challenge collateral from sender\\n\\n        // create dispute on arbitrator\\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\\n        (address recipient, ERC20 feeToken, uint256 feeAmount) = arbitrator.getDisputeFees();\\n        require(feeToken.safeTransferFrom(msg.sender, address(this), feeAmount), \\\"queue: bad fee pull\\\");\\n        require(feeToken.safeApprove(recipient, feeAmount), \\\"queue: bad approve\\\");\\n        disputeId = arbitrator.createDispute(2, abi.encode(_container)); // create dispute sending full container ABI encoded (could prob just send payload to save gas)\\n        require(feeToken.safeApprove(recipient, 0), \\\"queue: bad reset\\\"); // for security with non-compliant tokens (that fail on non-zero to non-zero approvals)\\n\\n        // submit both arguments as evidence and close evidence period. no more evidence can be submitted and a settlement can't happen (could happen off-protocol)\\n        emit EvidenceSubmitted(arbitrator, disputeId, _container.payload.submitter, _container.payload.proof, true);\\n        emit EvidenceSubmitted(arbitrator, disputeId, msg.sender, _reason, true);\\n        arbitrator.closeEvidencePeriod(disputeId);\\n\\n        disputeItemCache[arbitrator][disputeId] = containerHash; // cache a relation between disputeId and containerHash while needed\\n\\n        emit Challenged(containerHash, msg.sender, _reason, disputeId, collateral);\\n    }\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\\n       the current configuration of the system\\n     * @param _disputeId disputeId in the arbitrator in which the dispute over the container was created\\n     */\\n    function resolve(ERC3000Data.Container memory _container, uint256 _disputeId) override public returns (bytes32 failureMap, bytes[] memory execResults) {\\n        bytes32 containerHash = _container.hash();\\n        if (queue[containerHash].state == GovernQueueStateLib.State.Challenged) {\\n            // will re-enter in `rule`, `rule` will perform state transition depending on ruling\\n            IArbitrator(_container.config.resolver).executeRuling(_disputeId);\\n        } // else continue, as we must \\n\\n        GovernQueueStateLib.State state = queue[containerHash].state;\\n\\n        emit Resolved(containerHash, msg.sender, state == GovernQueueStateLib.State.Approved);\\n\\n        if (state == GovernQueueStateLib.State.Approved) {\\n            return executeApproved(_container);\\n        }\\n\\n        require(state == GovernQueueStateLib.State.Rejected, \\\"queue: unresolved\\\");\\n        settleRejection(_container);\\n        return (bytes32(0), new bytes[](0));\\n    }\\n\\n    function veto(bytes32 _containerHash, bytes memory _reason) auth(this.veto.selector) override public {\\n        queue[_containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Scheduled,\\n            GovernQueueStateLib.State.Cancelled\\n        );\\n\\n        emit Vetoed(_containerHash, msg.sender, _reason);\\n    }\\n\\n    /**\\n     * @notice Apply a new configuration for all *new* containers to be scheduled\\n     * @param _config A ERC3000Data.Config struct holding all the new params that will control the queue\\n     */\\n    function configure(ERC3000Data.Config memory _config)\\n        public\\n        override\\n        auth(this.configure.selector)\\n        returns (bytes32)\\n    {\\n        return _setConfig(_config);\\n    }\\n\\n    // Finalization functions\\n    // In the happy path, they are not externally called (triggered from resolve -> rule -> executeApproved | settleRejection), but left public for security\\n\\n    function executeApproved(ERC3000Data.Container memory _container) public returns (bytes32 failureMap, bytes[] memory execResults) {\\n        bytes32 containerHash = _container.hash();\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Approved,\\n            GovernQueueStateLib.State.Executed\\n        );\\n\\n        // release all collateral to submitter\\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter);\\n        _container.config.challengeDeposit.releaseTo(_container.payload.submitter);\\n\\n        challengerCache[containerHash] = address(0); // release state, refund gas, no longer needed in state\\n\\n        return _execute(_container.payload, containerHash);\\n    }\\n\\n    function settleRejection(ERC3000Data.Container memory _container) public {\\n        bytes32 containerHash = _container.hash();\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Rejected,\\n            GovernQueueStateLib.State.Cancelled\\n        );\\n\\n        address challenger = challengerCache[containerHash];\\n\\n        // release all collateral to challenger\\n        _container.config.scheduleDeposit.releaseTo(challenger);\\n        _container.config.challengeDeposit.releaseTo(challenger);\\n        challengerCache[containerHash] = address(0); // release state, refund gas, no longer needed in state\\n    }\\n\\n    // Arbitrable\\n\\n    function rule(uint256 _disputeId, uint256 _ruling) override external {\\n        // implicit check that msg.sender was actually arbitrating a dispute over this container\\n        IArbitrator arbitrator = IArbitrator(msg.sender);\\n        bytes32 containerHash = disputeItemCache[arbitrator][_disputeId];\\n        queue[containerHash].checkAndSetState(\\n            GovernQueueStateLib.State.Challenged,\\n            _ruling == ALLOW_RULING ? GovernQueueStateLib.State.Approved : GovernQueueStateLib.State.Rejected\\n        );\\n        disputeItemCache[arbitrator][_disputeId] = bytes32(0); // refund gas, no longer needed in state\\n\\n        emit Ruled(arbitrator, _disputeId, _ruling);\\n    }\\n\\n    function submitEvidence(\\n        uint256,\\n        bytes calldata,\\n        bool\\n    ) external override {\\n        revert(\\\"queue: evidence\\\");\\n    }\\n\\n    // Internal\\n\\n    function _execute(ERC3000Data.Payload memory _payload, bytes32 _containerHash) internal returns (bytes32, bytes[] memory) {\\n        emit Executed(_containerHash, msg.sender);\\n        return _payload.executor.exec(_payload.actions, _payload.allowFailuresMap, _containerHash);\\n    }\\n\\n    function _setConfig(ERC3000Data.Config memory _config)\\n        internal\\n        returns (bytes32)\\n    {\\n        configHash = _config.hash();\\n\\n        emit Configured(configHash, msg.sender, _config);\\n\\n        return configHash;\\n    }\\n}\\n\",\"keccak256\":\"0x3ba5d7e3b4a1776c4e1dee0e1fccb5f8312227e011a274a0c5b6576ac4e87e99\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/GovernMinter.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\n\\nimport \\\"./GovernToken.sol\\\";\\nimport \\\"./MerkleDistributor.sol\\\";\\n\\ncontract GovernMinter is ACL {\\n    using ERC1167ProxyFactory for address;\\n\\n    bytes4 constant internal MINT_ROLE =\\n        this.mint.selector ^\\n        this.merkleMint.selector\\n    ;\\n\\n    GovernToken public token;\\n    address public distributorBase;\\n\\n    event MintedSingle(address indexed to, uint256 amount, bytes context);\\n    event MintedMerkle(address indexed distributor, bytes32 indexed merkleRoot, uint256 totalAmount, bytes tree, bytes context);\\n\\n    constructor(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) ACL(_initialMinter) public {\\n        initialize(_token, _initialMinter, _distributorBase);\\n    }\\n\\n    function initialize(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) public initACL(_initialMinter) onlyInit(\\\"minter\\\") {\\n        token = _token;\\n        distributorBase = address(_distributorBase);\\n        _grant(MINT_ROLE, _initialMinter);\\n    }\\n\\n    function mint(address _to, uint256 _amount, bytes calldata _context) external auth(MINT_ROLE) {\\n        token.mint(_to, _amount);\\n        emit MintedSingle(_to, _amount, _context);\\n    }\\n\\n    function merkleMint(bytes32 _merkleRoot, uint256 _totalAmount, bytes calldata _tree, bytes calldata _context) external auth(MINT_ROLE) returns (MerkleDistributor distributor) {\\n        address distributorAddr = distributorBase.clone(abi.encodeWithSelector(distributor.initialize.selector, token, _merkleRoot));\\n        token.mint(distributorAddr, _totalAmount);\\n\\n        emit MintedMerkle(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\\n\\n        return MerkleDistributor(distributorAddr);\\n    }\\n\\n    function eject(address _newMinter) external auth(this.eject.selector) {\\n        token.changeMinter(_newMinter);\\n    }\\n}\\n\",\"keccak256\":\"0xe1a35f6c178ccdb2647ae8e9f631a242750ac8354ff1b7b92277688c6b80f044\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/GovernToken.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\\\";\\n\\nimport './interfaces/IERC20.sol';\\nimport './libraries/SafeMath.sol';\\n\\n// Copied and slightly modified from https://github.com/aragon/aragon-network-token/blob/v2-v1.0.0/packages/v2/contracts/token.sol\\n// Lightweight token modelled after UNI-LP: https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\\n// Adds:\\n//   - An exposed `mint()` with minting role\\n//   - An exposed `burn()`\\n//   - ERC-3009 (`transferWithAuthorization()`)\\ncontract GovernToken is IERC20, Initializable {\\n    using SafeMath for uint256;\\n\\n    // bytes32 private constant EIP712DOMAIN_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    // bytes32 private constant VERSION_HASH = keccak256(\\\"1\\\")\\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\\n    //     keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\");\\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    address public minter;\\n    uint256 override public totalSupply;\\n    mapping (address => uint256) override public balanceOf;\\n    mapping (address => mapping (address => uint256)) override public allowance;\\n\\n    // ERC-2612, ERC-3009 state\\n    mapping (address => uint256) public nonces;\\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n    event ChangeMinter(address indexed minter);\\n\\n    modifier onlyMinter {\\n        require(msg.sender == minter, \\\"token: not minter\\\");\\n        _;\\n    }\\n\\n    constructor(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public {\\n        initialize(_initialMinter, _name, _symbol, _decimals);\\n    }\\n\\n    function initialize(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public onlyInit(\\\"token\\\") {\\n        _changeMinter(_initialMinter);\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                getDomainSeparator(),\\n                encodeData\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \\\"token: bad sig\\\");\\n    }\\n\\n    function _changeMinter(address newMinter) internal {\\n        minter = newMinter;\\n        emit ChangeMinter(newMinter);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        // Balance is implicitly checked with SafeMath's underflow protection\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) private {\\n        require(to != address(this) && to != address(0), \\\"token: bad to\\\");\\n\\n        // Balance is implicitly checked with SafeMath's underflow protection\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function getChainId() public pure returns (uint256 chainId) {\\n        assembly { chainId := chainid() }\\n    }\\n\\n    function getDomainSeparator() public view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                EIP712DOMAIN_HASH,\\n                keccak256(abi.encodePacked(name)),\\n                VERSION_HASH,\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\\n        _mint(to, value);\\n        return true;\\n    }\\n\\n    function changeMinter(address newMinter) external onlyMinter {\\n        _changeMinter(newMinter);\\n    }\\n\\n    function burn(uint256 value) external returns (bool) {\\n        _burn(msg.sender, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) override external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) override external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) override external returns (bool) {\\n        uint256 fromAllowance = allowance[from][msg.sender];\\n        if (fromAllowance != uint256(-1)) {\\n            // Allowance is implicitly checked with SafeMath's underflow protection\\n            allowance[from][msg.sender] = fromAllowance.sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, \\\"token: auth expired\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\\n        _validateSignedData(owner, encodeData, v, r, s);\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        require(block.timestamp > validAfter, \\\"token: auth wait\\\");\\n        require(block.timestamp < validBefore, \\\"token: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"token: auth used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transfer(from, to, value);\\n    }\\n}\\n\",\"keccak256\":\"0xab0e7a980c386b294036194f6d062ceda5fef25be5821ba5219534da04ceb269\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/GovernTokenFactory.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\n\\nimport \\\"./GovernToken.sol\\\";\\nimport \\\"./GovernMinter.sol\\\";\\nimport \\\"./MerkleDistributor.sol\\\";\\n\\ncontract GovernTokenFactory {\\n    using ERC1167ProxyFactory for address;\\n    \\n    address public tokenBase;\\n    address public minterBase;\\n    address public distributorBase;\\n\\n    event CreatedToken(GovernToken token, GovernMinter minter);\\n\\n    constructor() public {\\n        setupBases();\\n    }\\n\\n    function newToken(\\n        address _initialMinter,\\n        string calldata _tokenName,\\n        string calldata _tokenSymbol,\\n        uint8 _tokenDecimals,\\n        address _mintAddr,\\n        uint256 _mintAmount,\\n        bool _useProxies\\n    ) external returns (\\n        GovernToken token,\\n        GovernMinter minter\\n    ) {\\n        if (!_useProxies) {\\n            (token, minter) = _deployContracts(_initialMinter, _tokenName, _tokenSymbol, _tokenDecimals);\\n        } else {\\n            token = GovernToken(tokenBase.clone(abi.encodeWithSelector(\\n                token.initialize.selector,\\n                address(this),\\n                _tokenName,\\n                _tokenSymbol,\\n                _tokenDecimals\\n            ))); \\n            minter = GovernMinter(minterBase.clone(abi.encodeWithSelector(\\n                minter.initialize.selector,\\n                token,\\n                address(this),\\n                MerkleDistributor(distributorBase)\\n            )));\\n        }\\n\\n        token.changeMinter(address(minter));\\n        if (_mintAmount > 0) minter.mint(_mintAddr, _mintAmount, \\\"initial mint\\\");\\n\\n        bytes4 mintRole = minter.mint.selector ^ minter.merkleMint.selector;\\n        bytes4 rootRole = minter.ROOT_ROLE();\\n\\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](4);\\n\\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, mintRole, _initialMinter);\\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, rootRole, _initialMinter);\\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Revoke, mintRole, address(this));\\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Revoke, rootRole, address(this));\\n\\n        minter.bulk(items);\\n\\n        emit CreatedToken(token, minter);\\n    }\\n\\n    function setupBases() private {\\n        distributorBase = address(new MerkleDistributor(ERC20(tokenBase), bytes32(0)));\\n        \\n        (GovernToken token, GovernMinter minter) = _deployContracts(\\n            address(this),\\n            \\\"GovernToken base\\\",\\n            \\\"GTB\\\",\\n            0\\n        );\\n        token.changeMinter(address(minter));\\n\\n        // test the bases\\n        minter.mint(msg.sender, 1, \\\"test mint\\\");\\n        minter.merkleMint(bytes32(0), 1, \\\"no tree\\\", \\\"test merkle mint\\\");\\n\\n        // store bases\\n        tokenBase = address(token);\\n        minterBase = address(minter);\\n    }\\n\\n    function _deployContracts(\\n        address _initialMinter,\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        uint8 _tokenDecimals\\n    ) internal returns (\\n        GovernToken token,\\n        GovernMinter minter\\n    ) {\\n        token = new GovernToken(address(this), _tokenName, _tokenSymbol, _tokenDecimals);\\n        minter = new GovernMinter(GovernToken(token), address(_initialMinter), MerkleDistributor(distributorBase));\\n    }\\n}\\n\",\"keccak256\":\"0x0c40058cbfbaa3e845b09f146d64f86a649a1f3c202b55d73b71a61af337e47a\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/MerkleDistributor.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\n// Copied and modified from: https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\\\";\\n\\ncontract MerkleDistributor is Initializable {\\n    using SafeERC20 for ERC20;\\n\\n    ERC20 public token;\\n    bytes32 public merkleRoot;\\n\\n    // This is a packed array of booleans.\\n    mapping (uint256 => uint256) private claimedBitMap;\\n\\n    event Claimed(uint256 indexed index, address indexed to, uint256 amount);\\n\\n    constructor(ERC20 _token, bytes32 _merkleRoot) public {\\n        initialize(_token, _merkleRoot);\\n    }\\n\\n    function initialize(ERC20 _token, bytes32 _merkleRoot) public onlyInit(\\\"distributor\\\") {\\n        token = _token;\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    function claim(uint256 _index, address _to, uint256 _amount, bytes32[] calldata _merkleProof) external {\\n        require(!isClaimed(_index), \\\"dist: already claimed\\\");\\n        require(_verifyBalanceOnTree(_index, _to, _amount, _merkleProof), \\\"dist: proof failed\\\");\\n\\n        _setClaimed(_index);\\n        token.safeTransfer(_to, _amount);\\n\\n        emit Claimed(_index, _to, _amount);\\n    }\\n\\n    function unclaimedBalance(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) public view returns (uint256) {\\n        if (isClaimed(_index)) return 0;\\n        return _verifyBalanceOnTree(_index, _to, _amount, _proof) ? _amount : 0;\\n    }\\n\\n    function _verifyBalanceOnTree(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) internal view returns (bool) {\\n        bytes32 node = keccak256(abi.encodePacked(_index, _to, _amount));\\n        return !MerkleProof.verify(_proof, merkleRoot, node);\\n    }\\n\\n    function isClaimed(uint256 _index) public view returns (bool) {\\n        uint256 claimedWord_index = _index / 256;\\n        uint256 claimedBit_index = _index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWord_index];\\n        uint256 mask = (1 << claimedBit_index);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    function _setClaimed(uint256 _index) private {\\n        uint256 claimedWord_index = _index / 256;\\n        uint256 claimedBit_index = _index % 256;\\n        claimedBitMap[claimedWord_index] = claimedBitMap[claimedWord_index] | (1 << claimedBit_index);\\n    }\\n}\",\"keccak256\":\"0x0aa0cd9a0315d598cefe72c7e25597e7b13576758469448e9a0cb769aa706946\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/interfaces/IERC20.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbed499479e4f3313d3529772756ff7bb9f2f3a0e4d9986b80d9daa3096141d98\",\"license\":\"GPL-3.0\"},\"@aragon/govern-token/contracts/libraries/SafeMath.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity ^0.6.8;\\n\\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\\n// Modified to include only the essentials\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"math: overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"math: underflow\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xa6d07240dedbe974aee70a66d71e5bb8ade51cbc8b00df9c46d7a204f637ba05\",\"license\":\"GPL-3.0\"},\"@openzeppelin/contracts/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\",\"keccak256\":\"0x96a652802a06645a5908f74f104ec95ff0897e261e7028ee319bafc55582b597\",\"license\":\"MIT\"},\"contracts/GovernBaseFactory.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-core/contracts/GovernRegistry.sol\\\";\\n\\nimport \\\"@aragon/govern-token/contracts/GovernTokenFactory.sol\\\";\\nimport \\\"@aragon/govern-token/contracts/interfaces/IERC20.sol\\\";\\n\\nimport \\\"./core-factories/GovernFactory.sol\\\";\\nimport \\\"./core-factories/GovernQueueFactory.sol\\\";\\n\\ncontract GovernBaseFactory {\\n    address internal constant ANY_ADDR = address(-1);\\n\\n    GovernFactory public governFactory;\\n    GovernQueueFactory public queueFactory;\\n    GovernTokenFactory public tokenFactory;\\n    GovernRegistry public registry;\\n\\n    constructor(\\n        GovernRegistry _registry,\\n        GovernFactory _governFactory,\\n        GovernQueueFactory _queueFactory,\\n        GovernTokenFactory _tokenFactory\\n    ) public {\\n        governFactory = _governFactory;\\n        queueFactory = _queueFactory;\\n        tokenFactory = _tokenFactory;\\n        registry = _registry;\\n    }\\n\\n    function newGovernWithoutConfig(\\n        string calldata _name,\\n        IERC20 _token,\\n        string calldata _tokenName,\\n        string calldata _tokenSymbol,\\n        bool _useProxies\\n    ) external returns (Govern govern, GovernQueue queue) {\\n        bytes32 salt = _useProxies ? keccak256(abi.encodePacked(_name)) : bytes32(0);\\n\\n        queue = queueFactory.newQueue(address(this), dummyConfig(), salt);\\n        govern = governFactory.newGovern(queue, salt);\\n\\n        if (address(_token) == address(0)) {\\n            (_token,) = tokenFactory.newToken(\\n                address(this),\\n                _tokenName,\\n                _tokenSymbol,\\n                18, // NOTE: hardcoding due to stack to deep issues\\n                msg.sender,\\n                1 * 10 ** 18,\\n                _useProxies\\n            );\\n        }\\n\\n        registry.register(govern, queue, _token, _name, \\\"\\\");\\n\\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](6);\\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.schedule.selector, ANY_ADDR);\\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.execute.selector, ANY_ADDR);\\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.challenge.selector, ANY_ADDR);\\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.configure.selector, address(govern));\\n        items[4] = ACLData.BulkItem(ACLData.BulkOp.Revoke, queue.ROOT_ROLE(), address(this));\\n        items[5] = ACLData.BulkItem(ACLData.BulkOp.Freeze, queue.ROOT_ROLE(), address(0));\\n        \\n        queue.bulk(items);\\n    }\\n\\n    function dummyConfig() internal pure returns (ERC3000Data.Config memory) {\\n        ERC3000Data.Collateral memory noCollateral;\\n        return ERC3000Data.Config(\\n            0,\\n            noCollateral,\\n            noCollateral,\\n            address(0),\\n            \\\"\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xf9b76dd93a9a3f294fbfeb5ff69a5344a0569979d9fb6c25493bcc986b020a01\",\"license\":\"GPL-3.0\"},\"contracts/core-factories/GovernFactory.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\nimport \\\"@aragon/govern-core/contracts/Govern.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\\\";\\n\\ncontract GovernFactory {\\n    using ERC1167ProxyFactory for address;\\n    using AddressUtils for address;\\n    \\n    address public base;\\n\\n    constructor() public {\\n        setupBase();\\n    }\\n\\n    function newGovern(IERC3000 _initialExecutor, bytes32 _salt) public returns (Govern govern) {\\n        if (_salt != bytes32(0)) {\\n            return Govern(base.clone2(_salt, abi.encodeWithSelector(govern.initialize.selector, _initialExecutor)).toPayable());\\n        } else {\\n            return new Govern(address(_initialExecutor));\\n        }\\n    }\\n\\n    function setupBase() private {\\n        base = address(new Govern(address(2)));\\n    }\\n}\\n\",\"keccak256\":\"0x4362cbf84ea0899e0bd269b719093c96c9153b79df73479ca798a222915bf552\",\"license\":\"GPL-3.0\"},\"contracts/core-factories/GovernQueueFactory.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@aragon/govern-core/contracts/pipelines/GovernQueue.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\n\\ncontract GovernQueueFactory {\\n    using ERC1167ProxyFactory for address;\\n\\n    address public base;\\n\\n    constructor() public {\\n        setupBase();\\n    }\\n\\n    function newQueue(address _aclRoot, ERC3000Data.Config memory _config, bytes32 _salt) public returns (GovernQueue queue) {\\n        if (_salt != bytes32(0)) {\\n            return GovernQueue(base.clone2(_salt, abi.encodeWithSelector(queue.initialize.selector, _aclRoot, _config)));\\n        } else {\\n            return new GovernQueue(_aclRoot, _config);\\n        }\\n    }\\n\\n    function setupBase() private {\\n        ERC3000Data.Collateral memory noCollateral;\\n        ERC3000Data.Config memory config = ERC3000Data.Config(\\n            0,\\n            noCollateral,\\n            noCollateral,\\n            address(0),\\n            \\\"\\\"\\n        );\\n        base = address(new GovernQueue(address(2), config));\\n    }\\n}\\n\",\"keccak256\":\"0x6782fb1fcfa38b6ab4e9ed632486034e1f0cfa84f96859176693d90dda7f06c3\",\"license\":\"GPL-3.0\"},\"erc3k/contracts/ERC3000Data.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nlibrary ERC3000Data {\\n    // TODO: come up with a non-shitty name\\n    struct Container {\\n        Payload payload;\\n        Config config;\\n    }\\n\\n    // WARN: Always remember to change the 'hash' function if modifying the struct\\n    struct Payload {\\n        uint256 nonce;\\n        uint256 executionTime;\\n        address submitter;\\n        IERC3000Executor executor;\\n        Action[] actions;\\n        bytes32 allowFailuresMap;\\n        bytes proof;\\n    }\\n\\n    struct Action {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct Config {\\n        uint256 executionDelay;\\n        Collateral scheduleDeposit;\\n        Collateral challengeDeposit;\\n        address resolver;\\n        bytes rules;\\n    }\\n\\n    struct Collateral {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        return keccak256(abi.encodePacked(\\\"erc3k-v1\\\", address(this), chainId, payloadHash, configHash));\\n    }\\n\\n    function hash(Container memory container) internal view returns (bytes32) {\\n        return containerHash(hash(container.payload), hash(container.config));\\n    }\\n\\n    function hash(Payload memory payload) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                payload.nonce,\\n                payload.executionTime,\\n                payload.submitter,\\n                payload.executor,\\n                keccak256(abi.encode(payload.actions)),\\n                payload.allowFailuresMap,\\n                keccak256(payload.proof)\\n            )\\n        );\\n    }\\n\\n    function hash(Config memory config) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(config));\\n    }\\n}\\n\",\"keccak256\":\"0x361ff1535d9950c8140bc71ec5102018bf2c14d7d33fef965ccea0656866bab5\",\"license\":\"MIT\"},\"erc3k/contracts/IERC3000.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\ncontract ERC3000Interface {\\n    bytes4 internal constant ERC3000_INTERFACE_ID =\\n        IERC3000(0).schedule.selector\\n        ^ IERC3000(0).execute.selector\\n        ^ IERC3000(0).challenge.selector\\n        ^ IERC3000(0).resolve.selector\\n        ^ IERC3000(0).veto.selector\\n        ^ IERC3000(0).configure.selector\\n    ;\\n}\\n\\nabstract contract IERC3000 is ERC3000Interface {\\n    /**\\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\\n     * @param container A Container struct holding both the payload being scheduled for execution and\\n       the current configuration of the system\\n     * @return containerHash\\n     */\\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\\n\\n    /**\\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\\n     * @param container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\\n       the current configuration of the system\\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(bytes32 indexed containerHash, address indexed actor);\\n\\n    /**\\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n       the current configuration of the system\\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\\n     * @return resolverId\\n     */\\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n       the current configuration of the system\\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param containerHash Hash of the container being vetoed\\n     * @param reason Justification for the veto\\n     */\\n    function veto(bytes32 containerHash, bytes memory reason) virtual public;\\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\\n\\n    /**\\n     * @notice Apply a new configuration for all *new* containers to be scheduled\\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\\n     * @return configHash\\n     */\\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\\n    event Configured(bytes32 indexed containerHash, address indexed actor, ERC3000Data.Config config);\\n}\\n\",\"keccak256\":\"0x274bc6206afff001e43f8c51ecddc1af5f6576cb0cf8738669211e7a384398b2\",\"license\":\"MIT\"},\"erc3k/contracts/IERC3000Executor.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000Executor {\\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\\n\\n    /**\\n     * @notice Executes all given actions\\n     * @param actions A array of ERC3000Data.Action for later executing those\\n     * @param allowFailuresMap A map with the allowed failures\\n     * @param memo The hash of the ERC3000Data.Container\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\\n}\\n\",\"keccak256\":\"0x568a412f560f477d831f5bc0bec927045686eea66a3a797c3f6784c7acefbf74\",\"license\":\"MIT\"},\"erc3k/contracts/IERC3000Registry.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"./IERC3000.sol\\\";\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nimport \\\"@aragon/govern-token/contracts/interfaces/IERC20.sol\\\";\\n\\nabstract contract IERC3000Registry is ERC3000Interface {\\n    /**\\n     * @notice Registers a IERC3000Executor and IERC3000 contract by a name and with his metadata\\n     * @param executor IERC3000Executor contract\\n     * @param queue IERC3000 contract\\n     * @param name The name of this DAO\\n     * @param token Governance token of the DAO\\n     * @param initialMetadata Additional data to store for this DAO\\n     */\\n    function register(IERC3000Executor executor, IERC3000 queue, IERC20 token, string calldata name, bytes calldata initialMetadata) virtual external;\\n    event Registered(IERC3000Executor indexed executor, IERC3000 queue, IERC20 indexed token, address indexed registrant, string name);\\n\\n    /**\\n     * @notice Sets or updates the metadata of a DAO\\n     * @param metadata Additional data to store for this DAO\\n     */\\n    function setMetadata(bytes memory metadata) virtual public;\\n    event SetMetadata(IERC3000Executor indexed executor, bytes metadata);\\n}\\n\",\"keccak256\":\"0x04ec42671ea3601d9a50f227d666ac187d0712b24b168edaf1c037ac38c83973\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610f67380380610f6783398101604081905261002f91610083565b600080546001600160a01b03199081166001600160a01b03958616179091556001805482169385169390931790925560028054831691841691909117905560038054909116929091169190911790556100f9565b60008060008060808587031215610098578384fd5b84516100a3816100e1565b60208601519094506100b4816100e1565b60408601519093506100c5816100e1565b60608601519092506100d6816100e1565b939692955090935050565b6001600160a01b03811681146100f657600080fd5b50565b610e5f806101086000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c8063894095161161005057806389409516146100925780639fd39b7d1461009a578063e77772fe146100bb57610067565b80636ca4110e1461006c5780637b1039991461008a575b600080fd5b6100746100c3565b6040516100819190610d3a565b60405180910390f35b6100746100df565b6100746100fb565b6100ad6100a8366004610a08565b610117565b604051610081929190610d81565b610074610831565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b60035473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b600080600083610128576000610152565b8a8a60405160200161013b929190610b37565b604051602081830303815290604052805190602001205b60015490915073ffffffffffffffffffffffffffffffffffffffff1663a0b19f4a3061017c61084d565b846040518463ffffffff1660e01b815260040161019b93929190610bba565b602060405180830381600087803b1580156101b557600080fd5b505af11580156101c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ed91906109b3565b6000546040517fad921bf400000000000000000000000000000000000000000000000000000000815291935073ffffffffffffffffffffffffffffffffffffffff169063ad921bf4906102469085908590600401610d5b565b602060405180830381600087803b15801561026057600080fd5b505af1158015610274573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061029891906109b3565b925073ffffffffffffffffffffffffffffffffffffffff8916610379576002546040517f20a8202000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116906320a82020906103249030908c908c908c908c906012903390670de0b6b3a7640000908f90600401610b47565b6040805180830381600087803b15801561033d57600080fd5b505af1158015610351573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037591906109cf565b5098505b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630b90502884848c8f8f6040518663ffffffff1660e01b81526004016103dc959493929190610da8565b600060405180830381600087803b1580156103f657600080fd5b505af115801561040a573d6000803e3d6000fd5b505060408051600680825260e08201909252606093509150816020015b61042f6108b1565b81526020019060019003908161042757905050604080516060810190915290915080600081527f977d896400000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff604090910152815182906000906104a357fe5b6020908102919091010152604080516060810190915280600081527f3a139c7100000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff60409091015281518290600190811061050e57fe5b6020908102919091010152604080516060810190915280600081527f7057615800000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff60409091015281518290600290811061057957fe5b6020908102919091010152604080516060810190915280600081527f7289676100000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff86166040909101528151829060039081106105e657fe5b6020908102919091010152604080516060810190915280600181526020018473ffffffffffffffffffffffffffffffffffffffff16637e8c7f086040518163ffffffff1660e01b815260040160206040518083038186803b15801561064a57600080fd5b505afa15801561065e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610682919061096c565b7fffffffff00000000000000000000000000000000000000000000000000000000168152306020909101528151829060049081106106bc57fe5b6020908102919091010152604080516060810190915280600281526020018473ffffffffffffffffffffffffffffffffffffffff16637e8c7f086040518163ffffffff1660e01b815260040160206040518083038186803b15801561072057600080fd5b505afa158015610734573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610758919061096c565b7fffffffff00000000000000000000000000000000000000000000000000000000168152600060209091015281518290600590811061079357fe5b60209081029190910101526040517f1c47671b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841690631c47671b906107f0908490600401610c9f565b600060405180830381600087803b15801561080a57600080fd5b505af115801561081e573d6000803e3d6000fd5b5050505050509850989650505050505050565b60025473ffffffffffffffffffffffffffffffffffffffff1681565b6108556108d3565b61085d61090e565b6040518060a0016040528060008152602001828152602001828152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016040518060200160405280600081525081525091505090565b6040805160608101909152806000815260006020820181905260409091015290565b6040518060a00160405280600081526020016108ed61090e565b81526020016108fa61090e565b815260006020820152606060409091015290565b604080518082019091526000808252602082015290565b60008083601f840112610936578182fd5b50813567ffffffffffffffff81111561094d578182fd5b60208301915083602082850101111561096557600080fd5b9250929050565b60006020828403121561097d578081fd5b81517fffffffff00000000000000000000000000000000000000000000000000000000811681146109ac578182fd5b9392505050565b6000602082840312156109c4578081fd5b81516109ac81610e04565b600080604083850312156109e1578081fd5b82516109ec81610e04565b60208401519092506109fd81610e04565b809150509250929050565b60008060008060008060008060a0898b031215610a23578384fd5b883567ffffffffffffffff80821115610a3a578586fd5b610a468c838d01610925565b909a50985060208b01359150610a5b82610e04565b90965060408a01359080821115610a70578586fd5b610a7c8c838d01610925565b909750955060608b0135915080821115610a94578485fd5b50610aa18b828c01610925565b90945092505060808901358015158114610ab9578182fd5b809150509295985092959890939650565b600082845282826020860137806020848601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011685010190509392505050565b805173ffffffffffffffffffffffffffffffffffffffff168252602090810151910152565b6000828483379101908152919050565b600073ffffffffffffffffffffffffffffffffffffffff808c16835260e06020840152610b7860e084018b8d610aca565b8381036040850152610b8b818a8c610aca565b60ff9890981660608501525094909416608082015260a0810192909252151560c0909101525095945050505050565b600073ffffffffffffffffffffffffffffffffffffffff808616835260206060818501528551606085015280860151610bf66080860182610b12565b506040860151610c0960c0860182610b12565b50816060870151166101008501526080860151915060e0610120850152815180610140860152835b81811015610c4e5783810183015186820161016001528201610c31565b81811115610c60578461016083880101525b506040850195909552505050601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016016101600192915050565b602080825282518282018190526000919060409081850190868401855b82811015610d2d578151805160038110610cd257fe5b8552808701517fffffffff00000000000000000000000000000000000000000000000000000000168786015285015173ffffffffffffffffffffffffffffffffffffffff168585015260609093019290850190600101610cbc565b5091979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b73ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352808716602084015280861660408401525060a06060830152610dea60a083018486610aca565b828103608090930192909252815260200195945050505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610e2657600080fd5b5056fea26469706673582212204e64d9e1f3c7d0e4d327c16a76dde889bd68c85c391ab0f3a7aff8c0d22ef84164736f6c63430006080033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c8063894095161161005057806389409516146100925780639fd39b7d1461009a578063e77772fe146100bb57610067565b80636ca4110e1461006c5780637b1039991461008a575b600080fd5b6100746100c3565b6040516100819190610d3a565b60405180910390f35b6100746100df565b6100746100fb565b6100ad6100a8366004610a08565b610117565b604051610081929190610d81565b610074610831565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b60035473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b600080600083610128576000610152565b8a8a60405160200161013b929190610b37565b604051602081830303815290604052805190602001205b60015490915073ffffffffffffffffffffffffffffffffffffffff1663a0b19f4a3061017c61084d565b846040518463ffffffff1660e01b815260040161019b93929190610bba565b602060405180830381600087803b1580156101b557600080fd5b505af11580156101c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ed91906109b3565b6000546040517fad921bf400000000000000000000000000000000000000000000000000000000815291935073ffffffffffffffffffffffffffffffffffffffff169063ad921bf4906102469085908590600401610d5b565b602060405180830381600087803b15801561026057600080fd5b505af1158015610274573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061029891906109b3565b925073ffffffffffffffffffffffffffffffffffffffff8916610379576002546040517f20a8202000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116906320a82020906103249030908c908c908c908c906012903390670de0b6b3a7640000908f90600401610b47565b6040805180830381600087803b15801561033d57600080fd5b505af1158015610351573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037591906109cf565b5098505b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630b90502884848c8f8f6040518663ffffffff1660e01b81526004016103dc959493929190610da8565b600060405180830381600087803b1580156103f657600080fd5b505af115801561040a573d6000803e3d6000fd5b505060408051600680825260e08201909252606093509150816020015b61042f6108b1565b81526020019060019003908161042757905050604080516060810190915290915080600081527f977d896400000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff604090910152815182906000906104a357fe5b6020908102919091010152604080516060810190915280600081527f3a139c7100000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff60409091015281518290600190811061050e57fe5b6020908102919091010152604080516060810190915280600081527f7057615800000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff60409091015281518290600290811061057957fe5b6020908102919091010152604080516060810190915280600081527f7289676100000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff86166040909101528151829060039081106105e657fe5b6020908102919091010152604080516060810190915280600181526020018473ffffffffffffffffffffffffffffffffffffffff16637e8c7f086040518163ffffffff1660e01b815260040160206040518083038186803b15801561064a57600080fd5b505afa15801561065e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610682919061096c565b7fffffffff00000000000000000000000000000000000000000000000000000000168152306020909101528151829060049081106106bc57fe5b6020908102919091010152604080516060810190915280600281526020018473ffffffffffffffffffffffffffffffffffffffff16637e8c7f086040518163ffffffff1660e01b815260040160206040518083038186803b15801561072057600080fd5b505afa158015610734573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610758919061096c565b7fffffffff00000000000000000000000000000000000000000000000000000000168152600060209091015281518290600590811061079357fe5b60209081029190910101526040517f1c47671b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841690631c47671b906107f0908490600401610c9f565b600060405180830381600087803b15801561080a57600080fd5b505af115801561081e573d6000803e3d6000fd5b5050505050509850989650505050505050565b60025473ffffffffffffffffffffffffffffffffffffffff1681565b6108556108d3565b61085d61090e565b6040518060a0016040528060008152602001828152602001828152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016040518060200160405280600081525081525091505090565b6040805160608101909152806000815260006020820181905260409091015290565b6040518060a00160405280600081526020016108ed61090e565b81526020016108fa61090e565b815260006020820152606060409091015290565b604080518082019091526000808252602082015290565b60008083601f840112610936578182fd5b50813567ffffffffffffffff81111561094d578182fd5b60208301915083602082850101111561096557600080fd5b9250929050565b60006020828403121561097d578081fd5b81517fffffffff00000000000000000000000000000000000000000000000000000000811681146109ac578182fd5b9392505050565b6000602082840312156109c4578081fd5b81516109ac81610e04565b600080604083850312156109e1578081fd5b82516109ec81610e04565b60208401519092506109fd81610e04565b809150509250929050565b60008060008060008060008060a0898b031215610a23578384fd5b883567ffffffffffffffff80821115610a3a578586fd5b610a468c838d01610925565b909a50985060208b01359150610a5b82610e04565b90965060408a01359080821115610a70578586fd5b610a7c8c838d01610925565b909750955060608b0135915080821115610a94578485fd5b50610aa18b828c01610925565b90945092505060808901358015158114610ab9578182fd5b809150509295985092959890939650565b600082845282826020860137806020848601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011685010190509392505050565b805173ffffffffffffffffffffffffffffffffffffffff168252602090810151910152565b6000828483379101908152919050565b600073ffffffffffffffffffffffffffffffffffffffff808c16835260e06020840152610b7860e084018b8d610aca565b8381036040850152610b8b818a8c610aca565b60ff9890981660608501525094909416608082015260a0810192909252151560c0909101525095945050505050565b600073ffffffffffffffffffffffffffffffffffffffff808616835260206060818501528551606085015280860151610bf66080860182610b12565b506040860151610c0960c0860182610b12565b50816060870151166101008501526080860151915060e0610120850152815180610140860152835b81811015610c4e5783810183015186820161016001528201610c31565b81811115610c60578461016083880101525b506040850195909552505050601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016016101600192915050565b602080825282518282018190526000919060409081850190868401855b82811015610d2d578151805160038110610cd257fe5b8552808701517fffffffff00000000000000000000000000000000000000000000000000000000168786015285015173ffffffffffffffffffffffffffffffffffffffff168585015260609093019290850190600101610cbc565b5091979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b73ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352808716602084015280861660408401525060a06060830152610dea60a083018486610aca565b828103608090930192909252815260200195945050505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610e2657600080fd5b5056fea26469706673582212204e64d9e1f3c7d0e4d327c16a76dde889bd68c85c391ab0f3a7aff8c0d22ef84164736f6c63430006080033",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4259,
        "contract": "contracts/GovernBaseFactory.sol:GovernBaseFactory",
        "label": "governFactory",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(GovernFactory)4612"
      },
      {
        "astId": 4261,
        "contract": "contracts/GovernBaseFactory.sol:GovernBaseFactory",
        "label": "queueFactory",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(GovernQueueFactory)4711"
      },
      {
        "astId": 4263,
        "contract": "contracts/GovernBaseFactory.sol:GovernBaseFactory",
        "label": "tokenFactory",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(GovernTokenFactory)3829"
      },
      {
        "astId": 4265,
        "contract": "contracts/GovernBaseFactory.sol:GovernBaseFactory",
        "label": "registry",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(GovernRegistry)1722"
      }
    ],
    "types": {
      "t_contract(GovernFactory)4612": {
        "encoding": "inplace",
        "label": "contract GovernFactory",
        "numberOfBytes": "20"
      },
      "t_contract(GovernQueueFactory)4711": {
        "encoding": "inplace",
        "label": "contract GovernQueueFactory",
        "numberOfBytes": "20"
      },
      "t_contract(GovernRegistry)1722": {
        "encoding": "inplace",
        "label": "contract GovernRegistry",
        "numberOfBytes": "20"
      },
      "t_contract(GovernTokenFactory)3829": {
        "encoding": "inplace",
        "label": "contract GovernTokenFactory",
        "numberOfBytes": "20"
      }
    }
  }
}